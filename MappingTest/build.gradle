buildscript {
	repositories {
		jcenter()
		maven { url "https://plugins.gradle.org/m2/" }
		maven {
			url "https://maven.fabricmc.net"
			content { desc ->
				desc.includeGroup("net.fabricmc")
			}
		}
	}
	dependencies {
		classpath 'org.minimallycorrect.gradle:DefaultsPlugin:0.1.5'
	}
}
plugins {
	id 'java'
	id 'java-library'
	id 'maven-publish'
	//id 'org.minimallycorrect.mixin.gradle-plugin' version '0.0.6-SNAPSHOT'
	id 'dev.minco.mapping' version '0.0.1-SNAPSHOT'
}

import dev.minco.mapping.GradleExtensions
import dev.minco.mapping.LocalMavenWorkaround
/*
import org.minimallycorrect.mixinplugin.deps.GeneratedDependency
import org.minimallycorrect.mixinplugin.deps.MModuleComponentIdentifier
import org.gradle.api.internal.file.FileCollectionInternal
 */

sourceSets.main.java.srcDirs = files('src')
sourceSets.test.java.srcDirs = files('test')

apply plugin: 'org.minimallycorrect.gradle.DefaultsPlugin'

group = 'dev.minco.test'

minimallyCorrectDefaults {
	bintray = false
	languageLevel = JavaVersion.VERSION_11
	configureProject(project)
}

ext.repo = new File(project.buildDir, "mappingWorkaroundM2")

repositories {
	maven {
		url repo
		name 'mappingWorkaroundM2'
	}
	maven {
		url 'https://maven.fabricmc.net/'
		name 'fabricmc'
		content { desc ->
			desc.includeGroup("net.fabricmc")
		}
	}
	jcenter()
}

def mcMappedAttribute = mapping.getMappingArtifactForTarget("net.minecraft")
ext.aValidAttrValueWhichCanBeTransformedToRequired = "net.fabricmc:intermediary:1.15.2:intermediary"
ext.moduleMetadataAttrValue = ext.aValidAttrValueWhichCanBeTransformedToRequired
ext.setComponentMetadataRule = false
ext.attrDefaultValue = null
if (project.hasProperty("TEST")) {
	switch (TEST) {
		case "0":
			break;
		case "1":
			ext.moduleMetadataAttrValue = null
			ext.setComponentMetadataRule = true
			break;
		case "2":
			ext.moduleMetadataAttrValue = null
			break;
		case "3":
			ext.moduleMetadataAttrValue = null
			ext.attrDefaultValue = ext.aValidAttrValueWhichCanBeTransformedToRequired
			break;
		case "4":
			ext.attrDefaultValue = ext.aValidAttrValueWhichCanBeTransformedToRequired
			break;
		default:
			throw new RuntimeException("Unknown -PTEST= value " + TEST)
	}

	System.err.println("Applied -PTEST= settings " + TEST)
}

if (ext.attrDefaultValue != null) {
	System.setProperty("dev.minco.mapping.defaultAttrValueTest", ext.attrDefaultValue)
}
System.err.println("moduleMetadataAttrValue: " + ext.moduleMetadataAttrValue);
System.err.println("component metadata rule used: " + ext.setComponentMetadataRule)
System.err.println("default attr value overridden: " + ext.attrDefaultValue)
System.err.println("This build is expected to fail with the error \"TODO: Actually transform.\". If build succeeds, transforms weren't ran as expected.\n")

mapping {
	def yarn115 = "net.fabricmc:yarn:1.15.2+build.9:v2"
	registerMapping(project, "net.minecraft", "net.fabricmc:intermediary:1.15.2")
	registerMapping(project, "net.minecraft", yarn115)
	registerNamespaceTranslator {
		if (it == "$yarn115:intermediary") {
			return "net.fabricmc:intermediary:1.15.2:intermediary"
		}
	}
	registerDefaultMappedConfiguration(project, "net.minecraft", "$yarn115:named")
}

def generatedMinecraftMerged() {
	// TODO: actually merge with server jar and use task's output file collection
	// simple demo/test, enough to hit issue

	// https://launchermeta.mojang.com/mc/game/version_manifest.json
	def clientJar = new URL("https://launcher.mojang.com/v1/objects/e3f78cd16f9eb9a52307ed96ebec64241cc5b32d/client.jar")

	def dlCfg = GradleExtensions.createSingleFileConfigurationForUrl(project, clientJar)
	def file = dlCfg.fileCollection { Dependency spec ->
		return true
	}

	// we could just do this, but that leaves the group/module/version unset
	// makes so can't target with metadata rule
	// return file

	// This also doesn't work, as component metadata rules are silently ignored for generated dependencies.
	// return new GeneratedDependency(new MModuleComponentIdentifier("net.minecraft", "minecraft", "1.15.2-obf-client"), (FileCollectionInternal) file)

	// We create a local maven repo with one artifact in it and then we can use a component metadata rule to target it OR we can can generate a gradle module metadata file
	// Last arg is set to the mapped attr value to use in the module metadata file, or if null no .module file is created
	LocalMavenWorkaround.createLocalMavenRepoForSingleFile(project.ext.repo, file.singleFile, "net.minecraft", "minecraft", "1.15.2", project.ext.moduleMetadataAttrValue)

	return "net.minecraft:minecraft:1.15.2"
}

dependencies {
	implementation(generatedMinecraftMerged())

	if (project.ext.setComponentMetadataRule) {
		components { components ->
			components.withModule("net.minecraft:minecraft") { ComponentMetadataDetails rule ->
				rule.allVariants { variant ->
					variant.attributes {
						container ->
							container.attribute(mcMappedAttribute, project.ext.aValidAttrValueWhichCanBeTransformedToRequired)
					}
				}
			}
		}
	}
}
allprojects {
	configurations {
		all {
			resolutionStrategy {
				failOnVersionConflict()
				failOnNonReproducibleResolution()

			}
		}
	}
}
